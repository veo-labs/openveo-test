<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>lib\e2e\pages\TablePage.js - OpenVeo test API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">OpenVeo test API</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 4.1.0
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/BackEndPage.html">BackEndPage</a></li>
                                <li><a href="../classes/browser.html">browser</a></li>
                                <li><a href="../classes/CheckboxesField.html">CheckboxesField</a></li>
                                <li><a href="../classes/CheckboxField.html">CheckboxField</a></li>
                                <li><a href="../classes/DateField.html">DateField</a></li>
                                <li><a href="../classes/Field.html">Field</a></li>
                                <li><a href="../classes/Helper.html">Helper</a></li>
                                <li><a href="../classes/i18n.html">i18n</a></li>
                                <li><a href="../classes/karma-ng-inline-templates-preprocessor.html">karma-ng-inline-templates-preprocessor</a></li>
                                <li><a href="../classes/Page.html">Page</a></li>
                                <li><a href="../classes/screenshotPlugin.html">screenshotPlugin</a></li>
                                <li><a href="../classes/SelectField.html">SelectField</a></li>
                                <li><a href="../classes/TableAssert.html">TableAssert</a></li>
                                <li><a href="../classes/TablePage.html">TablePage</a></li>
                                <li><a href="../classes/TagsField.html">TagsField</a></li>
                                <li><a href="../classes/TextareaField.html">TextareaField</a></li>
                                <li><a href="../classes/TextField.html">TextField</a></li>
                                <li><a href="../classes/TimeField.html">TimeField</a></li>
                                <li><a href="../classes/TinyMCEField.html">TinyMCEField</a></li>
                                <li><a href="../classes/util.html">util</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/e2e.html">e2e</a></li>
                                <li><a href="../modules/unit.html">unit</a></li>
                                <li><a href="../modules/util.html">util</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib\e2e\pages\TablePage.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/**
 * @module e2e
 */

var util = require(&#x27;util&#x27;);
var browserExt = process.requireTest(&#x27;lib/e2e/browser.js&#x27;);
var BackEndPage = process.requireTest(&#x27;lib/e2e/pages/BackEndPage.js&#x27;);

/**
 * Defines a TablePage representing a back end page with a table and form to add an entity.
 *
 * Do not use this directly but extend it.
 *
 * @example
 *
 *     var TablePage = require(&#x27;@openveo/test&#x27;).e2e.pages.TablePage;
 *
 *     function MyTablePage() {
 *       MyTablePage.super_.call(this);
 *       this.path = &#x27;be/myTablePage&#x27;;
 *     }
 *
 *     module.exports = MyTablePage;
 *     util.inherits(MyTablePage, TablePage);
 *
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load().then(function() {
 *       console.log(&#x27;Page fully loaded in the first language&#x27;);
 *     });
 *
 * @class TablePage
 * @extends BackEndPage
 * @constructor
 * @param {EntityModel} model Model to interact directly with the database
 */
function TablePage(model) {
  TablePage.super_.call(this);
  var addFormElement = element(by.css(&#x27;.add-form&#x27;));
  var addLinkElement = element(by.css(&#x27;.add-element&#x27;));
  var tableElement = element(by.css(&#x27;.datatable table&#x27;));
  var dialogElement = element(by.css(&#x27;.modal-dialog&#x27;));
  var paginationElement = element(by.css(&#x27;.pagination&#x27;));
  var paginationLinkElements = paginationElement.all(by.css(&#x27;li&#x27;));

  Object.defineProperties(this, {

    /**
     * The entity model.
     *
     * @property model
     * @type EntityModel
     * @final
     */
    model: {value: model},

    /**
     * Form element to add a new entity.
     *
     * @property addFormElement
     * @type ElementFinder
     * @final
     */
    addFormElement: {value: addFormElement},

    /**
     * Link to open / close form element to add a new entity.
     *
     * @property addLinkElement
     * @type ElementFinder
     * @final
     */
    addLinkElement: {value: addLinkElement},

    /**
     * Wrapper of the add form element.
     *
     * This element will be displayed when add form is displayed and hidden when add form is closed.
     *
     * @property addFormWrapperElement
     * @type ElementFinder
     * @final
     */
    addFormWrapperElement: {
      value: addLinkElement.element(by.xpath(&#x27;..&#x27;))
      .all(by.css(&#x27;div[uib-collapse=&quot;isCollapsed&quot;]&#x27;)).first()
    },

    /**
     * Submit button of the form to add a new entity.
     *
     * @property addButtonElement
     * @type ElementFinder
     * @final
     */
    addButtonElement: {value: addFormElement.element(by.css(&#x27;button&#x27;))},

    /**
     * Table element.
     *
     * @property tableElement
     * @type ElementFinder
     * @final
     */
    tableElement: {value: tableElement},

    /**
     * Table row elements.
     *
     * @property rowElements
     * @type ElementArrayFinder
     * @final
     */
    rowElements: {value: tableElement.all(by.css(&#x27;tbody &gt; tr&#x27;))},

    /**
     * Table header elements.
     *
     * @property headerElements
     * @type ElementArrayFinder
     * @final
     */
    headerElements: {value: tableElement.all(by.css(&#x27;thead th&#x27;))},

    /**
     * Opened line detail containing information about the opened line.
     *
     * @property lineDetailElement
     * @type ElementFinder
     * @final
     */
    lineDetailElement: {value: element(by.css(&#x27;.datatable tr.detail&#x27;))},

    /**
     * Checkbox to select all line.
     *
     * @property selectAllElement
     * @type ElementFinder
     * @final
     */
    selectAllElement: {value: element(by.css(&#x27;.allactions input[type=&quot;checkbox&quot;]&#x27;))},

    /**
     * Main action button element to perform actions on all selected lines.
     *
     * @property actionsButtonElement
     * @type ElementFinder
     * @final
     */
    actionsButtonElement: {value: element(by.css(&#x27;.allactions button&#x27;))},

    /**
     * Element holding the list of actions under main action button.
     *
     * @property actionsElement
     * @type ElementFinder
     * @final
     */
    actionsElement: {value: element(by.css(&#x27;.allactions ul&#x27;))},

    /**
     * Dialog box.
     *
     * @property dialogElement
     * @type ElementFinder
     * @final
     */
    dialogElement: {value: dialogElement},

    /**
     * Dialog box confirmation button.
     *
     * @property dialogConfirmActionButtonElement
     * @type ElementFinder
     */
    dialogConfirmActionButtonElement: {value: dialogElement.element(by.css(&#x27;.btn-primary&#x27;))},

    /**
     * Dialog box cancel button.
     *
     * @property dialogCancelActionButtonElement
     * @type ElementFinder
     * @final
     */
    dialogCancelActionButtonElement: {value: dialogElement.element(by.css(&#x27;.btn-warning&#x27;))},

    /**
     * Search engine form to filter lines in the table.
     *
     * @property searchFormElement
     * @type ElementFinder
     * @final
     */
    searchFormElement: {value: element(by.css(&#x27;.search-fields&#x27;))},

    /**
     * Link to open / close search engine.
     *
     * @property searchLinkElement
     * @type ElementFinder
     * @final
     */
    searchLinkElement: {value: element(by.css(&#x27;.search-title&#x27;))},

    /**
     * Element holding the current table page (pagination).
     *
     * @property currentPageElement
     * @type ElementFinder
     * @final
     */
    currentPageElement: {value: element(by.exactBinding(&#x27;pagination.page&#x27;))},

    /**
     * Element holding the total number of table pages (pagination).
     *
     * @property totalPagesElement
     * @type ElementFinder
     * @final
     */
    totalPagesElement: {value: element(by.exactBinding(&#x27;pagination.pages&#x27;))},

    /**
     * Element holding the total number of lines in all table pages (pagination).
     *
     * @property totalLinesElement
     * @type ElementFinder
     * @final
     */
    totalLinesElement: {value: element(by.exactBinding(&#x27;pagination.size&#x27;))},

    /**
     * Pagination links wrapper.
     *
     * @property paginationElement
     * @type ElementFinder
     * @final
     */
    paginationElement: {value: element(by.css(&#x27;.pagination&#x27;))},

    /**
     * List of pagination links, including the previous and next range buttons.
     *
     * @property paginationLinkElements
     * @type ElementArrayFinder
     * @final
     */
    paginationLinkElements: {value: paginationLinkElements},

    /**
     * List of pagination links, excluding the previous and next range buttons.
     *
     * @property paginationPageLinkElements
     * @type ElementArrayFinder
     * @final
     */
    paginationPageLinkElements: {value: paginationElement.all(by.repeater(&#x27;numPage in rangePage&#x27;)).all(by.css(&#x27;a&#x27;))},

    /**
     * Pagination previous range link.
     *
     * @property paginationPreviousRangeElement
     * @type ElementFinder
     * @final
     */
    paginationPreviousRangeElement: {value: paginationLinkElements.first()},

    /**
     * Pagination next range link.
     *
     * @property paginationNextRangeElement
     * @type ElementFinder
     * @final
     */
    paginationNextRangeElement: {value: paginationLinkElements.last()},

    /**
     * List of per page links to select the number of elements to display per table page.
     *
     * @property itemsPerPageLinkElements
     * @type ElementArrayFinder
     * @final
     */
    itemsPerPageLinkElements: {value: element.all(by.repeater(&#x27;count in listItemsPerPageShow&#x27;))}

  });

}

module.exports = TablePage;
util.inherits(TablePage, BackEndPage);

/**
 * Finds a line.
 *
 * Iterate through the given list of lines to look for the expected one.
 *
 * @private
 * @method getLineByIndex
 * @param {Array} lines The list of line elements (tr elements) to look into
 * @param {String} name The name of the line to look for (this value will be compared to the value of each cell)
 * @param {Number} [index] The index in lines to start from
 * @return {Promise} Promise resolving with the tr element
 */
function getLineByIndex(lines, name, index) {
  index = index || 0;
  var deferred = protractor.promise.defer();
  var self = this;

  if (index &lt; lines.length &amp;&amp; lines.length) {
    var line = lines[index];

    self.lineCellContain(line, name).then(function(contain) {
      if (contain) {

        // Line found
        deferred.fulfill(line);

      } else {

        // Line not found

        // Try next line
        getLineByIndex.call(self, lines, name, ++index).then(function(elements) {
          deferred.fulfill(elements);
        }, function(error) {
          deferred.reject(error);
        });
      }

    });
  } else
    deferred.reject(new Error(&#x27;No lines corresponding to &#x27; + name));

  return deferred.promise;
}

/**
 * Finds a line by page.
 *
 * Iterate through all lines of all pages to look for the expected line.
 * It starts at current page.
 *
 * @private
 * @method getLineByPage
 * @param {String} name The name of the line to look for (this value will be compared to the value of each cell)
 * @param {Number} totalPages The total number of pages
 * @return {Promise} Promise resolving with the searched line (tr element)
 */
function getLineByPage(name, totalPages) {
  var self = this;
  var deferred = protractor.promise.defer();

  this.getLineInPage(name).then(function(line) {

    // Line find in current page
    deferred.fulfill(line);

  }, function(error) {

    // Line not found in current page

    self.getCurrentPage().then(function(currentPage) {
      if ((currentPage + 1) &lt;= totalPages) {

        // Got more pages

        // Select next page
        return self.selectPage(currentPage + 1).then(function() {

          // Get line in page
          return getLineByPage.call(self, name, totalPages);

        });

      } else {

        // No more page, line has not been found
        return protractor.promise.rejected(new Error(&#x27;No lines corresponding to &#x27; + name));

      }
    }).then(function(line) {
      deferred.fulfill(line);
    }, function(error) {
      deferred.reject(error);
    });

  });

  return deferred.promise;
}

/**
 * Selects a page.
 *
 * Look for page link in pagination links, if page link is not in the pagination actual range, it will search for
 * the page link in the other pagination ranges.
 *
 * @private
 * @method selectPageByRange
 * @param {String} page The page to select (starting at 1 instead of 0)
 * @return {Promise} Promise resolving when the page is selected
 */
function selectPageByRange(page) {
  var self = this;
  var deferred = protractor.promise.defer();

  // Filter the list of pagination links to get the link corresponding to the page
  this.paginationPageLinkElements.filter(function(element, index) {
    return element.all(by.css(&#x27;span&#x27;)).first().getText().then(function(text) {
      return text.replace(/ ?\(current\)/, &#x27;&#x27;) == page;
    });
  }).then(function(links) {
    if (links.length) {

      // Page link found

      // Click on it
      browserExt.click(links[0]).then(function() {
        deferred.fulfill();
      });

    } else {

      // Page link not found
      self.isNextRangeLinkEnabled().then(function(isEnabled) {
        if (isEnabled) {

          // There is a next range

          // Select next range
          self.selectNextPageRange();

          // Try to find the page in the next range
          return selectPageByRange.call(self, page);

        } else {

          // Already in last range
          // Page link not found
          return protractor.promise.rejected(new Error(&#x27;No page &#x27; + page + &#x27; found&#x27;));

        }

      }).then(function() {
        deferred.fulfill();
      }, function(error) {
        deferred.reject(error);
      });
    }
  });

  return deferred.promise;
}

/**
 * Gets the index of a table column in the list of columns.
 *
 * @private
 * @method getHeaderIndex
 * @param {String} name The name of the header to look for
 * @return {Promise} Promise resolving with the index of the column
 */
function getHeaderIndex(name) {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();
    var headerIndex = -1;

    self.headerElements.each(function(thElement, index) {
      thElement.getText().then(function(text) {
        if (text === name)
          headerIndex = index;
      });
    }).then(function() {
      if (headerIndex &gt;= 0)
        deferred.fulfill(headerIndex);
      else
        deferred.reject(new Error(&#x27;Table header &quot;&#x27; + name + &#x27;&quot; not found&#x27;));
    });

    return deferred.promise;
  });
}

/**
 * Gets column value for a list of lines.
 *
 * Iterates through the given list of lines and find its value in the given column.
 *
 * @private
 * @method getLineValuesByIndex
 * @param {Array} lines The lines in the page (tr elements)
 * @param {Number} headerIndex The index of the column to read
 * @param {Number} [index=0] Current line index being inspected
 * @return {Promise} Promise resolving with lines values
 */
function getLineValuesByIndex(lines, headerIndex, index) {
  index = index || 0;
  var self = this;
  var deferred = protractor.promise.defer();
  var values = [];
  var line = lines[index];

  self.getLineCellValue(line, headerIndex).then(function(text) {
    values.push(text);

    if ((index + 1) &lt; lines.length) {
      return getLineValuesByIndex.call(self, lines, headerIndex, ++index);
    } else {
      deferred.fulfill(values);
      return protractor.promise.rejected(new Error(&#x27;No more lines&#x27;));
    }

  }).then(function(newValues) {
    values = values.concat(newValues);
    deferred.fulfill(values);
  }).then(null, function(error) {

    // Nothing to do, promise is rejected but it&#x27;s not an error

  });

  return deferred.promise;
}

/**
 * Gets column and field values for a list of lines.
 *
 * Iterates through the given list of lines and get all information (column values and field values) for each line.
 *
 * @private
 * @method getAllLineDetailsByIndex
 * @param {Array} lines The lines in the page (tr elements)
 * @param {Number} [index=0] Current line index being inspected
 * @return {Promise} Promise resolving with values
 */
function getAllLineDetailsByIndex(lines, index) {
  index = index || 0;
  var self = this;
  var deferred = protractor.promise.defer();
  var datas = [];
  var line = lines[index];

  this.getLineDetails(line).then(function(details) {
    datas.push(details);

    if ((index + 1) &lt; lines.length) {

      // Got more lines

      // Go to next line
      return getAllLineDetailsByIndex.call(self, lines, ++index);
    } else {

      // No more lines
      deferred.fulfill(datas);
      return protractor.promise.fulfilled();
    }

  }).then(function(newDatas) {
    if (newDatas) {
      datas = datas.concat(newDatas);
      deferred.fulfill(datas);
    }
  });

  return deferred.promise;
}

/**
 * Gets line column values in all pages.
 *
 * Iterate through all lines of all pages and get column value for each line.
 * It starts at current page.
 *
 * @private
 * @method getLineValuesByPage
 * @param {Number} headerIndex The index of the column to read
 * @param {Number} totalPages The total number of pages
 * @return {Promise} Promise resolving with column values
 */
function getLineValuesByPage(headerIndex, totalPages) {
  var self = this;
  var values = [];
  var deferred = protractor.promise.defer();

  this.getLinesInPage().then(function(lines) {
    if (lines.length) {

      // Found lines in the page

      return getLineValuesByIndex.call(self, lines, headerIndex);
    } else {

      // No lines in the page

      return deferred.reject(new Error(&#x27;No lines&#x27;));
    }
  }).then(function(lineValuesInPage) {

    // Got line values in the page

    values = values.concat(lineValuesInPage);
    return self.getCurrentPage();
  }).then(function(currentPage) {
    if ((currentPage + 1) &lt;= totalPages) {

      // Got more pages

      // Select next page
      return self.selectPage(currentPage + 1);

    } else {

      // No more pages

      deferred.fulfill(values);
      return protractor.promise.rejected(new Error(&#x27;No more pages&#x27;));
    }
  }).then(function() {

    // Next page selected

    // Get all values in the page
    return getLineValuesByPage.call(self, headerIndex, totalPages);
  }).then(function(lineValuesInPage) {
    values = values.concat(lineValuesInPage);
    deferred.fulfill(values);
  }).then(null, function(error) {

    // Nothing to do, promise is rejected but it&#x27;s not an error

  });

  return deferred.promise;
}

/**
 * Gets line fields values in all pages.
 *
 * Iterate through all lines of all pages and get columns / fields values for each line.
 * It starts at current page.
 *
 * @private
 * @method getAllLineDetailsByPage
 * @param {Number} totalPages The total number of pages
 * @return {Promise} Promise resolving with values
 */
function getAllLineDetailsByPage(totalPages) {
  var self = this;
  var datas = [];
  var deferred = protractor.promise.defer();

  // Get all lines in the page
  this.getLinesInPage().then(function(lines) {
    if (lines.length) {

      // Found lines in the page

      // Get all information about each line
      return getAllLineDetailsByIndex.call(self, lines);
    } else {

      // No lines in the page

      return deferred.reject(new Error(&#x27;No lines&#x27;));
    }
  }).then(function(datasInPage) {

    // Got field datas in the page

    datas = datas.concat(datasInPage);
    return self.getCurrentPage();
  }).then(function(currentPage) {
    if ((currentPage + 1) &lt;= totalPages) {

      // Got more pages

      // Select next page
      return self.selectPage(currentPage + 1);

    } else {

      // No more pages

      deferred.fulfill(datas);
      return protractor.promise.rejected(new Error(&#x27;No more pages&#x27;));
    }
  }).then(function() {

    // Next page selected

    // Get all datas in the page
    return getAllLineDetailsByPage.call(self, totalPages);
  }).then(function(datasInPage) {
    datas = datas.concat(datasInPage);
    deferred.fulfill(datas);
  }).then(null, function(error) {

    // Nothing to do, promise is rejected but it&#x27;s not an error

  });

  return deferred.promise;
}

/**
 * Gets all lines in the table page except the opened one.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLinesInPage().then(function(lines) {
 *       console.log(lines);
 *     });
 *
 * @method getLinesInPage
 * @return {Promise} Promise resolving with the list of lines elements in the page (tr elements)
 */
TablePage.prototype.getLinesInPage = function() {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();

    self.rowElements.filter(function(rowElement, index) {
      return rowElement.getAttribute(&#x27;class&#x27;).then(function(classes) {
        classes = classes.split(&#x27; &#x27;);
        return classes.indexOf(&#x27;detail&#x27;) &lt; 0;
      });
    }).then(function(lines) {
      deferred.fulfill(lines);
    }, function(error) {
      deferred.reject(error);
    });

    return deferred.promise;
  });
};

/**
 * Gets a line within the current page.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineInPage(&#x27;My line&#x27;).then(function(line) {
 *       console.log(line);
 *     });
 *
 * @method getLineInPage
 * @param {String} name The name of the line to look for (each column will be compared to this value)
 * @return {Promise} Promise resolving with the line (tr element)
 */
TablePage.prototype.getLineInPage = function(name) {
  var self = this;

  // Get all lines except opened ones
  return this.getLinesInPage().then(function(lines) {

    // Got all lines except opened lines
    return getLineByIndex.call(self, lines, name);

  });
};

/**
 * Gets the number of lines in the current page.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLinesInPageNumber().then(function(linesNumber) {
 *       console.log(&#x27;This page contains &#x27; + linesNumber + &#x27; lines&#x27;);
 *     });
 *
 * @method getLinesInPageNumber
 * @return {Promise} Promise resolving with the number of lines in the page
 */
TablePage.prototype.getLinesInPageNumber = function() {
  return this.getLinesInPage().then(function(lines) {
    return protractor.promise.fulfilled(lines.length);
  });
};

/**
 * Opens add form.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.openAddForm().then(function() {
 *       console.log(&#x27;Add form opened&#x27;);
 *     });
 *
 * @method openAddForm
 * @return {Promise} Promise resolving when add form is opened
 */
TablePage.prototype.openAddForm = function() {
  var self = this;

  return this.addFormWrapperElement.isDisplayed().then(function(isDisplayed) {
    if (!isDisplayed) {

      // Open add form
      browserExt.click(self.addLinkElement);

      return browser.wait(self.EC.visibilityOf(self.addFormWrapperElement), 1000, &#x27;Missing add form&#x27;);
    } else {

      // Add form is already displayed
      return protractor.promise.fulfilled();

    }
  }).then(function() {
    return protractor.promise.fulfilled();
  });
};

/**
 * Closes formular to add an item.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.openAddForm();
 *     page.closeAddForm().then(function() {
 *       console.log(&#x27;Add form closed&#x27;);
 *     });
 *
 * @method closeAddForm
 * @return {Promise} Promise resolving when add form is closed
 */
TablePage.prototype.closeAddForm = function() {
  var self = this;

  return this.addFormWrapperElement.isDisplayed().then(function(isDisplayed) {
    if (isDisplayed) {

      // Close add form
      browserExt.click(self.addLinkElement);

      // Wait for the menu to be invisible
      return browser.wait(self.EC.invisibilityOf(self.addFormWrapperElement), 1000, &#x27;Add form still visible&#x27;);
    } else {

      // Add form is already closed
      return protractor.promise.fulfilled();

    }
  }).then(function() {
    return protractor.promise.fulfilled();
  });
};

/**
 * Submit formular to add an item.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.submitAddForm().then(function() {
 *       console.log(&#x27;Add form submitted&#x27;);
 *     });
 *
 * @method submitAddForm
 * @return {Promise} Promise resolving when add form submit button has been clicked
 */
TablePage.prototype.submitAddForm = function() {
  return browserExt.click(this.addButtonElement);
};

/**
 * Gets a line.
 *
 * Looks for a line in all pages.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLine(&#x27;My line&#x27;).then(function(line) {
 *       console.log(line);
 *     });
 *
 * @method getLine
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving with the line (tr element)
 */
TablePage.prototype.getLine = function(lineFinder) {
  var self = this;

  if (typeof lineFinder !== &#x27;string&#x27;)
    return protractor.promise.fulfilled(lineFinder);

  return browser.waitForAngular().then(function() {
    var promises = [self.getCurrentPage(), self.getTotalPages()];

    return protractor.promise.all(promises).then(function(values) {
      var currentPage = values[0];
      var totalPages = values[1];

      if (totalPages) {

        if (currentPage != 1)
          self.selectPage(1);

        return getLineByPage.call(self, lineFinder, totalPages);

      } else {
        return protractor.promise.rejected(new Error(&#x27;No lines&#x27;));
      }

    });
  });
};

/**
 * Gets values of a column for all lines in all pages.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineValues(&#x27;Name&#x27;).then(function(values) {
 *      console.log(values);
 *     });
 *
 * @method getLineValues
 * @param {String} headerTitle Title of the column to extract values from
 * @return {Promise} Promise resolving with the list of values
 */
TablePage.prototype.getLineValues = function(headerTitle) {
  var self = this;

  return browser.waitForAngular().then(function() {
    var currentPage;
    var totalPages;
    var promises = [self.getCurrentPage(), self.getTotalPages()];

    return protractor.promise.all(promises).then(function(values) {
      currentPage = values[0];
      totalPages = values[1];

      if (totalPages) {
        if (currentPage != 1)
          self.selectPage(1);

        return getHeaderIndex.call(self, headerTitle);
      } else {
        return protractor.promise.rejected(new Error(&#x27;No lines&#x27;));
      }

    }).then(function(headerIndex) {
      return getLineValuesByPage.call(self, headerIndex, totalPages);
    });
  });
};

/**
 * Gets values of a column for all lines in current page.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineInPageValues(&#x27;Name&#x27;).then(function(values) {
 *      console.log(values);
 *     });
 *
 * @method getLineInPageValues
 * @param {String} headerTitle Title of the column to extract values from
 * @return {Promise} Promise resolving with the list of values
 */
TablePage.prototype.getLineInPageValues = function(headerTitle) {
  var self = this;

  return getHeaderIndex.call(this, headerTitle).then(function(headerIndex) {
    return self.getLinesInPage().then(function(lines) {
      if (lines.length) {

        // Found lines in the page

        return getLineValuesByIndex.call(self, lines, headerIndex);
      } else {

        // No lines in the page

        return protractor.promise.rejected(new Error(&#x27;No lines&#x27;));
      }
    });
  });
};

/**
 * Gets all column / fields values for all lines in all pages.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getAllLineDetails().then(function(data) {
 *      console.log(data);
 *     });
 *
 * @method getAllLineDetails
 * @return {Promise} Promise resolving with the list of line details
 */
TablePage.prototype.getAllLineDetails = function() {
  var self = this;

  return browser.waitForAngular().then(function() {
    var promises = [self.getCurrentPage(), self.getTotalPages()];
    var currentPage;
    var totalPages;

    return protractor.promise.all(promises).then(function(values) {
      currentPage = values[0];
      totalPages = values[1];

      if (totalPages) {
        if (currentPage != 1)
          self.selectPage(1);

        return getAllLineDetailsByPage.call(self, totalPages);
      } else {
        return protractor.promise.rejected(new Error(&#x27;No lines&#x27;));
      }
    });
  });
};

/**
 * Gets all column / field values of a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineDetails(&#x27;My line&#x27;).then(function(data) {
 *       console.log(data);
 *     });
 *
 * @method getLineDetails
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving with the line details
 */
TablePage.prototype.getLineDetails = function(lineFinder) {
  var self = this;

  return browser.waitForAngular().then(function() {
    var promises = [self.getLineCellValues(lineFinder), self.getLineFieldValues(lineFinder)];

    return protractor.promise.all(promises);
  }).then(function(values) {
    return protractor.promise.fulfilled({
      cells: values[0],
      fields: values[1]
    });
  });
};

/**
 * Gets all column values for a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineCells(&#x27;My line&#x27;).then(function(data) {
 *       console.log(data);
 *     });
 *
 * @method getLineCells
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving with the line column values
 */
TablePage.prototype.getLineCells = function(lineFinder) {
  var self = this;

  return this.getLine(lineFinder).then(function(line) {

    // Get all cell values
    return self.getLineCellValues(line);

  });
};

/**
 * Gets all fields values for a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineFieldValues(&#x27;My line&#x27;).then(function(data) {
 *       console.log(data);
 *     });
 *
 * @method getLineFieldValues
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving with the line fields values
 */
TablePage.prototype.getLineFieldValues = function(lineFinder) {
  var self = this;
  var fieldValues = {};

  var getFieldText = function(field, fieldName) {
    return field.getText().then(function(text) {
      fieldValues[fieldName] = text;
    }, function(error) {

      // Field couldn&#x27;t be found, maybe it is hidden
      fieldValues[fieldName] = null;

    });
  };

  return this.getLine(lineFinder).then(function(line) {
    var promises = [];

    // Close any opened line
    self.closeLine();

    // Open line
    self.openLine(line);

    // Get all field values
    var fields = self.getEditFormFields(self.lineDetailElement);
    for (var fieldId in fields)
      promises.push(getFieldText(fields[fieldId], fieldId));

    return protractor.promise.all(promises);
  }).then(function() {
    return protractor.promise.fulfilled(fieldValues);
  });
};

/**
 * Opens a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.openLine(&#x27;My line&#x27;).then(function() {
 *       console.log(&#x27;My line opened&#x27;);
 *     });
 *
 * @method openLine
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving when line is opened
 */
TablePage.prototype.openLine = function(lineFinder) {
  var self = this;

  return this.getLine(lineFinder).then(function(line) {

    // Click on the line to open it
    browserExt.click(line.all(by.css(&#x27;td&#x27;)).get(1));

    // Wait for the detail line
    return browser.wait(self.EC.presenceOf(self.lineDetailElement), 5000, &#x27;Missing opened line&#x27;);
  });
};

/**
 * Closes opened line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.closeLine(&#x27;My line&#x27;).then(function() {
 *       console.log(&#x27;My line closed&#x27;);
 *     });
 *
 * @method closeLine
 * @return {Promise} Promise resolving when line is closed
 */
TablePage.prototype.closeLine = function() {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();

    // Iterate on each line to find if one is an opened line
    self.rowElements.each(function(rowElement, index) {
      rowElement.getAttribute(&#x27;class&#x27;).then(function(classes) {
        classes = classes.split(&#x27; &#x27;);

        if (classes.indexOf(&#x27;detail&#x27;) &gt;= 0) {

          // Found an opened line

          // Close it
          // Line is on the previous line because the detail is displayed in a new line
          browserExt.click(self.rowElements.get(--index).all(by.css(&#x27;td&#x27;)).get(1));

          // Wait for the detail line to be closed
          browser.wait(self.EC.stalenessOf(self.lineDetailElement), 5000, &#x27;Line still opened&#x27;);

        }
      });
    }).then(function() {
      return deferred.fulfill();
    });

    return deferred.promise;
  });
};

/**
 * Tests if a line is opened.
 *
 * As only one line can be opened at a time, no name is required.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.isOpenedLine().then(function(isOpened) {
 *       console.log(&#x27;Is a line opened ? &#x27; + isOpened);
 *     });
 *
 * @method isOpenedLine
 * @return {Promise} Promise resolving with a boolean indicating if a line is opened or not
 */
TablePage.prototype.isOpenedLine = function() {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();
    var isOpened = false;

    // Iterate on each line to find if one is an opened line
    self.rowElements.each(function(rowElement, index) {
      rowElement.getAttribute(&#x27;class&#x27;).then(function(classes) {
        classes = classes.split(&#x27; &#x27;);

        if (classes.indexOf(&#x27;detail&#x27;) &gt;= 0)
          isOpened = true;
      });
    }).then(function() {
      deferred.fulfill(isOpened);
    });

    return deferred.promise;
  });
};

/**
 * Tests if a line is selected.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.isSelectedLine(&#x27;my line name&#x27;).then(function(isSelected) {
 *       console.log(&#x27;Is line selected ? &#x27; + isSelected);
 *     });
 *
 * @method isSelectedLine
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving with a boolean indicating if line is selected or not
 */
TablePage.prototype.isSelectedLine = function(lineFinder) {
  return this.getLine(lineFinder).then(function(line) {

    // Check if line is selected
    return line.element(by.css(&#x27;input[type=&quot;checkbox&quot;]&#x27;)).getAttribute(&#x27;checked&#x27;);

  });
};

/**
 * Selects a line by checking the line checkbox.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectLine(&#x27;My line&#x27;).then(function() {
 *       console.log(&#x27;My line is selected&#x27;);
 *     });
 *
 * @method selectLine
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving when line is selected
 */
TablePage.prototype.selectLine = function(lineFinder) {
  var self = this;
  return this.isSelectedLine(lineFinder).then(function(isSelected) {
    if (isSelected) return protractor.promise.fulfilled();
    return self.getLine(lineFinder).then(function(line) {

      // Click on line checkbox
      return browserExt.click(line.element(by.css(&#x27;input[type=&quot;checkbox&quot;]&#x27;)));

    });
  });
};

/**
 * Deselects a line by clicking on the line checkbox.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.deselectLine(&#x27;My line&#x27;).then(function() {
 *       console.log(&#x27;My line is deselected&#x27;);
 *     });
 *
 * @method deselectLine
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving when line is deselected
 */
TablePage.prototype.deselectLine = function(lineFinder) {
  var self = this;
  return this.isSelectedLine(lineFinder).then(function(isSelected) {
    if (!isSelected) return protractor.promise.fulfilled();
    return self.getLine(lineFinder).then(function(line) {

      // Click on line checkbox
      return browserExt.click(line.element(by.css(&#x27;input[type=&quot;checkbox&quot;]&#x27;)));

    });
  });
};

/**
 * Selects all lines.
 *
 * At least, one line must be in the table.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectAllLines().then(function() {
 *       console.log(&#x27;All lines selected&#x27;);
 *     });
 *
 * @method selectAllLines
 * @return {Promise} Promise resolving when all lines are selected
 */
TablePage.prototype.selectAllLines = function() {
  var self = this;

  return this.selectAllElement.getAttribute(&#x27;checked&#x27;).then(function(isChecked) {
    if (isChecked) return protractor.promise.fulfilled();
    browserExt.click(self.selectAllElement);
    return browser.wait(self.EC.visibilityOf(self.actionsButtonElement), 1000, &#x27;Missing the global action button&#x27;);
  });
};

/**
 * Sorts lines.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.sortBy(&#x27;Name&#x27;, true).then(function() {
 *       console.log(&#x27;Lines sorted by Name&#x27;);
 *     });
 *
 * @method sortBy
 * @param {String} name The value of the column to act on, each column will be compared to this value
 * @param {Boolean} asc true to sort in ascendant order, false to sort in descendant order
 * @return {Promise} Promise resolving when column is clicked
 */
TablePage.prototype.sortBy = function(name, asc) {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();

    self.headerElements.filter(function(thElement, index) {
      return thElement.getText().then(function(text) {
        return text === name;
      });
    }).then(function(thElements) {
      if (thElements.length) {
        var thElement = thElements[0];

        // Header found
        thElement.element(by.className(&#x27;glyphicon-triangle-bottom&#x27;)).isPresent().then(function(isPresent) {

          if ((isPresent &amp;&amp; asc) || (!isPresent &amp;&amp; !asc)) {
            deferred.fulfill();
          } else {
            browserExt.click(thElement).then(function() {
              deferred.fulfill();
            }, function(error) {
              deferred.reject(error);
            });
          }

        });


      } else {
        deferred.reject(new Error(&#x27;No header corresponding to &#x27; + name));
      }
    });

    return deferred.promise;
  });
};

/**
 * Performs an action on a single line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.performAction(&#x27;My line&#x27;, &#x27;Remove&#x27;).then(function() {
 *       console.log(&#x27;Action &quot;Remove&quot; has been performed on line &quot;My line&quot;, confirmation dialog is opened&#x27;);
 *     });
 *
 * @example
 *
 *     page.performAction(&#x27;My line&#x27;, &#x27;Remove&#x27;, true).then(function() {
 *       console.log(&#x27;&quot;My line&quot; removed&#x27;);
 *     });
 *
 * @method performAction
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @param {String} action The translated name of the action to perform
 * @param {Boolean} [confirm=false] true to confirm the action, false otherwise
 * @return {Promise} Promise resolving when action is performed
 */
TablePage.prototype.performAction = function(lineFinder, action, confirm) {
  var self = this;

  return this.getLine(lineFinder).then(function(line) {
    var actionTd = line.all(by.css(&#x27;td&#x27;)).last();
    var actionButton = actionTd.element(by.css(&#x27;button&#x27;));
    var actionElement = actionTd.element(by.cssContainingText(&#x27;a&#x27;, action));

    return actionElement.isDisplayed().then(function(isDisplayed) {

      // Click on action button
      if (!isDisplayed)
        browserExt.click(actionButton);

      // Click on the desired action
      browserExt.click(actionElement);

      if (confirm) {
        browser.wait(self.EC.visibilityOf(self.dialogElement), 5000, &#x27;Missing confirmation dialog&#x27;);
        return self.confirmAction();
      } else
        return protractor.promise.fulfilled();

    });

  });
};

/**
 * Performs a grouped action.
 *
 * At least one line must be selected.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectAllLines();
 *     page.performMultipleAction(&#x27;Remove&#x27;).then(function() {
 *       console.log(&#x27;Action &quot;Remove&quot; performed on all selected lines, confirmation dialog is opened&#x27;);
 *     });
 *
 * @example
 *
 *     page.performMultipleAction(&#x27;Remove&#x27;, true).then(function() {
 *       console.log(&#x27;All lines removed&#x27;);
 *     });
 *
 * @method performMultipleAction
 * @param {String} action The translated name of the action to perform
 * @param {Boolean} [confirm=false] true to confirm the action, false otherwise
 * @return {Promise} Promise resolving when the action is performed
 */
TablePage.prototype.performMultipleAction = function(action, confirm) {
  var self = this;
  return browserExt.click(this.actionsButtonElement).then(function() {
    browser.wait(self.EC.visibilityOf(self.actionsElement), 1000, &#x27;Missing the list of actions&#x27;);
    browserExt.click(self.actionsElement.element(by.cssContainingText(&#x27;a&#x27;, action)));

    if (confirm) {
      browser.wait(self.EC.visibilityOf(self.dialogElement), 5000, &#x27;Missing confirmation dialog&#x27;);
      return self.confirmAction();
    } else
      return protractor.promise.fulfilled();
  });
};

/**
 * Accepts the confirmation dialog.
 *
 * Confirmation dialog must be displayed.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectAllLines();
 *     page.performMultipleAction(&#x27;Remove&#x27;);
 *     page.confirmAction().then(function() {
 *       console.Log(&#x27;Dialog confirmed, thus all selected lines are removed&#x27;);
 *     });
 *
 * @method confirmAction
 * @return {Promise} Promise resolving when confirmation dialog has been accepted
 */
TablePage.prototype.confirmAction = function() {
  var self = this;

  return browserExt.click(this.dialogConfirmActionButtonElement).then(function() {
    return browser.wait(self.EC.stalenessOf(self.dialogElement), 5000, &#x27;Dialog still visible&#x27;);
  }).then(function() {
    return protractor.promise.fulfilled();
  });
};

/**
 * Cancels the confirmation dialog.
 *
 * Confirmation dialog must be displayed.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectAllLines();
 *     page.performMultipleAction(&#x27;Remove&#x27;);
 *     page.cancelAction().then(function() {
 *       console.Log(&#x27;Remoe action canceled&#x27;);
 *     });
 *
 * @method cancelAction
 * @return {Promise} Promise resolving when confirmation dialog has been canceled
 */
TablePage.prototype.cancelAction = function() {
  var self = this;
  return browserExt.click(this.dialogCancelActionButtonElement).then(function() {
    return browser.wait(self.EC.stalenessOf(self.dialogElement), 1000, &#x27;Dialog still visible&#x27;);
  }).then(function() {
    return protractor.promise.fulfilled();
  });
};

/**
 * Gets the list of available actions for a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineActions(&#x27;My line&#x27;).then(function(actions) {
 *       console.log(actions);
 *     });
 *
 * @method getLineActions
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving whith the list of actions
 */
TablePage.prototype.getLineActions = function(lineFinder) {
  return this.getLine(lineFinder).then(function(line) {
    var deferred = protractor.promise.defer();
    var actions = [];
    var actionElements;
    var actionTd = line.all(by.css(&#x27;td&#x27;)).last();
    var actionButton = actionTd.element(by.css(&#x27;button&#x27;));
    actionElements = actionTd.all(by.css(&#x27;a&#x27;));

    // Click on action button
    browserExt.click(actionButton);

    // Get action names
    actionElements.each(function(actionElement, index) {
      actionElement.getText().then(function(actionName) {
        actions.push(actionName);
      });
    }).then(function() {
      browserExt.click(actionButton);
    }).then(function() {
      deferred.fulfill(actions);
    });

    return deferred.promise;
  });
};

/**
 * Gets the list of global actions available.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getGlobalActions().then(function(actions) {
 *       console.log(actions);
 *     });
 *
 * @method getGlobalActions
 * @return {Promise} Promise resolving whith the list of global actions
 */
TablePage.prototype.getGlobalActions = function() {
  var self = this;

  return this.selectAllLines().then(function() {
    var deferred = protractor.promise.defer();
    var actions = [];
    var actionElements = self.actionsElement.all(by.css(&#x27;a&#x27;));

    browserExt.click(self.actionsButtonElement);
    browser.wait(self.EC.visibilityOf(self.actionsElement), 1000, &#x27;Missing the list of actions&#x27;).then(function() {

      // Get action names
      actionElements.each(function(actionElement, index) {
        actionElement.getText().then(function(actionName) {
          actions.push(actionName);
        });
      }).then(function() {
        deferred.fulfill(actions);
      });

    });

    return deferred.promise;
  });
};

/**
 * Searches in the list of lines using search engine.
 *
 * Fills search fields.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *
 *     var searchFieldsValues = {
 *       myField: &#x27;Value&#x27;
 *     };
 *
 *     page.search(searchFieldsValues).then(function() {
 *       console.Log(&#x27;Search done&#x27;);
 *     });
 *
 * @method search
 * @param {Object} fields List of values for fields returned by method getSearchFields
 * @return {Promise} Promise resolving when search is done
 */
TablePage.prototype.search = function(values) {
  var self = this;

  return this.openSearchEngine().then(function() {
    var promises = [];
    var fields = self.getSearchFields(self.searchFormElement);

    for (var fieldId in values)
      promises.push(fields[fieldId].setValue(values[fieldId]));

    return protractor.promise.all(promises);
  });
};

/**
 * Clears search fields.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.clearSearch().then(function() {
 *       console.Log(&#x27;Search engine cleared&#x27;);
 *     });
 *
 * @method clearSearch
 * @return {Promise} Promise resolving when fields are cleared
 */
TablePage.prototype.clearSearch = function() {
  var self = this;

  return this.openSearchEngine().then(function() {
    var promises = [];
    var fields = self.getSearchFields(self.searchFormElement);

    for (var fieldId in fields)
      promises.push(fields[fieldId].setValue());

    return protractor.promise.all(promises);
  });
};

/**
 * Opens search engine.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.openSearchEngine().then(function() {
 *       console.log(&#x27;Search engine opened&#x27;);
 *     });
 *
 * @method openSearchEngine
 * @return {Promise} Promise resolving when search engine is opened
 */
TablePage.prototype.openSearchEngine = function() {
  var self = this;

  return this.searchFormElement.isDisplayed().then(function(isDisplayed) {
    if (!isDisplayed) {

      // Open search engine
      browserExt.click(self.searchLinkElement);

      return browser.wait(self.EC.visibilityOf(self.searchFormElement), 1000, &#x27;Missing search form&#x27;);

    } else {

      // Search engine is already displayed
      return protractor.promise.fulfilled();

    }
  }).then(function() {
    return protractor.promise.fulfilled();
  });
};

/**
 * Closes search engine.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.closeSearchEngine().then(function() {
 *       console.log(&#x27;Search engine closed&#x27;);
 *     });
 *
 * @method closeSearchEngine
 * @return {Promise} Promise resolving when search engine is closed
 */
TablePage.prototype.closeSearchEngine = function() {
  var self = this;

  return this.searchFormElement.isDisplayed().then(function(isDisplayed) {
    if (isDisplayed) {

      // Close search engine
      browserExt.click(self.searchLinkElement);

      // Wait for the search engine to be invisible
      return browser.wait(self.EC.invisibilityOf(self.searchFormElement), 1000, &#x27;Search engine still visible&#x27;);
    } else {

      // Search engine is already closed
      return protractor.promise.fulfilled();

    }
  }).then(function() {
    return protractor.promise.fulfilled();
  });
};

/**
 * Gets current page number.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getCurrentPage().then(function(currentPage) {
 *       console.log(&#x27;Current page is &#x27; + currentPage);
 *     });
 *
 * @method getCurrentPage
 * @return {Promise} Promise resolving with the current page (starting at 1)
 */
TablePage.prototype.getCurrentPage = function() {
  return this.currentPageElement.getText().then(function(currentPage) {
    return protractor.promise.fulfilled(parseInt(currentPage));
  });
};

/**
 * Gets total number of pages.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getTotalPages().then(function(totalPages) {
 *       console.log(&#x27;There are &#x27; + totalPages + &#x27; pages&#x27;);
 *     });
 *
 * @method getTotalPages
 * @return {Promise} Promise resolving with the total number of pages
 */
TablePage.prototype.getTotalPages = function() {
  return this.totalPagesElement.getText().then(function(totalPages) {
    return protractor.promise.fulfilled(parseInt(totalPages));
  });
};

/**
 * Gets total number of lines.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getTotalLines().then(function(totalLines) {
 *       console.log(&#x27;There are &#x27; + totalLines + &#x27; lines&#x27;);
 *     });
 *
 * @method getTotalLines
 * @return {Promise} Promise resolving with the total number of lines
 */
TablePage.prototype.getTotalLines = function() {
  return this.totalLinesElement.getText().then(function(totalLines) {
    return protractor.promise.fulfilled(parseInt(totalLines));
  });
};

/**
 * Gets the total number of page links.
 *
 * Gets the number of page links in the pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getTotalPaginationLinks().then(function(totalLinks) {
 *       console.log(&#x27;There are &#x27; + totalLinks + &#x27; pagination links&#x27;);
 *     });
 *
 * @method getTotalPaginationLinks
 * @return {Promise} Promise resolving with the total number of links
 */
TablePage.prototype.getTotalPaginationLinks = function() {
  return this.paginationLinkElements.count().then(function(count) {
    var totalLinks = count - 2;
    return protractor.promise.fulfilled(totalLinks);
  });
};

/**
 * Selects the first page in pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectFirstPage().then(function() {
 *       console.log(&#x27;First page selected&#x27;);
 *     });
 *
 * @method selectFirstPage
 * @return {Promise} Promise resolving when first page is selected
 */
TablePage.prototype.selectFirstPage = function() {
  return this.selectPage(1);
};

/**
 * Selects the last page in pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectLastPage().then(function() {
 *       console.log(&#x27;Last page selected&#x27;);
 *     });
 *
 * @method selectLastPage
 * @return {Promise} Promise resolving when last page is selected
 */
TablePage.prototype.selectLastPage = function() {
  var self = this;

  return this.getTotalPages().then(function(totalPages) {
    return self.selectPage(totalPages);
  });
};

/**
 * Selects a page in pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectPage(5).then(function() {
 *       console.log(&#x27;Page 5 selected&#x27;);
 *     });
 *
 * @method selectPage
 * @param {Number} page The page to select (starting at 1)
 * @return {Promise} Promise resolving when page is selected
 */
TablePage.prototype.selectPage = function(page) {
  var self = this;
  return this.selectFirstPageRange().then(function() {
    return selectPageByRange.call(self, page);
  });
};

/**
 * Selects first page range in pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectFirstPageRange().then(function() {
 *       console.log(&#x27;First range selected&#x27;);
 *     });
 *
 * @method selectFirstPageRange
 * @return {Promise} Promise resolving when first page range is selected
 */
TablePage.prototype.selectFirstPageRange = function() {
  var self = this;

  return this.isPreviousRangeLinkEnabled().then(function(isEnabled) {
    if (isEnabled) {
      self.selectPreviousPageRange();
      return self.selectFirstPageRange();
    } else {

      // Already in first range
      return protractor.promise.fulfilled();

    }
  });
};

/**
 * Selects last page range in pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectLastPageRange().then(function() {
 *       console.log(&#x27;Last range selected&#x27;);
 *     });
 *
 * @method selectLastPageRange
 * @return {Promise} Promise resolving when last page range is selected
 */
TablePage.prototype.selectLastPageRange = function() {
  var self = this;

  return this.isNextRangeLinkEnabled().then(function(isEnabled) {
    if (isEnabled) {

      self.selectNextPageRange();
      return self.selectLastPageRange();

    } else {

      // Already in first range
      return protractor.promise.fulfilled();

    }
  });
};

/**
 * Selects previous page range in pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectPreviousPageRange().then(function() {
 *       console.log(&#x27;Previous range selected&#x27;);
 *     });
 *
 * @method selectPreviousPageRange
 * @return {Promise} Promise resolving when previous page range is selected
 */
TablePage.prototype.selectPreviousPageRange = function() {
  return browserExt.click(this.paginationPreviousRangeElement);
};

/**
 * Selects next page range in pagination.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.selectNextPageRange().then(function() {
 *       console.log(&#x27;Next range selected&#x27;);
 *     });
 *
 * @method selectNextPageRange
 * @return {Promise} Promise resolving when next page range is selected
 */
TablePage.prototype.selectNextPageRange = function() {
  return browserExt.click(this.paginationNextRangeElement);
};

/**
 * Tests if previous page range link is enabled.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.isPreviousRangeLinkEnabled().then(function(isEnabled) {
 *       console.log(&#x27;Is previous range link enabled ?&#x27; + isEnabled);
 *     });
 *
 * @method isPreviousRangeLinkEnabled
 * @return {Promise} Promise resolving whith a boolean indicating if the previous range link is enabled
 */
TablePage.prototype.isPreviousRangeLinkEnabled = function() {
  return this.paginationPreviousRangeElement.getAttribute(&#x27;class&#x27;).then(function(classes) {
    classes = classes.split(&#x27; &#x27;);
    return protractor.promise.fulfilled(classes.indexOf(&#x27;disabled&#x27;) &lt; 0);
  });
};

/**
 * Tests if next page range link is enabled.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.isNextRangeLinkEnabled().then(function(isEnabled) {
 *       console.log(&#x27;Is next range link enabled ?&#x27; + isEnabled);
 *     });
 *
 * @method isNextRangeLinkEnabled
 * @return {Promise} Promise resolving whith a boolean indicating if the next range link is enabled
 */
TablePage.prototype.isNextRangeLinkEnabled = function() {
  return this.paginationNextRangeElement.getAttribute(&#x27;class&#x27;).then(function(classes) {
    classes = classes.split(&#x27; &#x27;);
    return protractor.promise.fulfilled(classes.indexOf(&#x27;disabled&#x27;) &lt; 0);
  });
};

/**
 * Sets the desired number of lines to display in the table.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.setLinesNumber(20).then(function() {
 *       console.log(&#x27;20 lines are now displayed per page&#x27;);
 *     });
 *
 * @method setLinesNumber
 * @param {Number} linesNumbers Either 5, 10, 20 or 30
 * @return {Promise} Promise resolving when the expected number of lines is set
 */
TablePage.prototype.setLinesNumber = function(linesNumber) {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();

    self.itemsPerPageLinkElements.filter(function(link, index) {
      return link.getText().then(function(text) {
        return text == linesNumber;
      });
    }).then(function(links) {
      if (links.length) {
        var link = links[0];

        link.getAttribute(&#x27;class&#x27;).then(function(classes) {
          classes = classes.split(&#x27; &#x27;);
          if (classes.indexOf(&#x27;active&#x27;) &gt;= 0) {
            deferred.fulfill();
          } else {
            browserExt.click(link).then(function() {
              deferred.fulfill();
            }, function(error) {
              deferred.reject(error);
            });
          }
        });
      } else {
        deferred.reject(new Error(&#x27;No element found for &#x27; + linesNumber + &#x27; items per page&#x27;));
      }
    }).then(function(error) {
      deferred.reject(error);
    });

    return deferred.promise;
  });
};

/**
 * Moves the cursor over the &quot;select all&quot; checkbox to display the information popover.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.setSelectAllMouseOver().then(function() {
 *       console.log(&#x27;Mouse over the &quot;select all&quot; checkbox&#x27;);
 *     });
 *
 * @method setSelectAllMouseOver
 * @return {Promise} Promise resolving when the mouse is over the &quot;select all&quot; checkbox
 */
TablePage.prototype.setSelectAllMouseOver = function() {
  var self = this;

  return browser.actions().mouseMove(this.selectAllElement).perform().then(function() {
    return browser.wait(self.EC.presenceOf(self.popoverElement), 1000, &#x27;Missing dialog over select all checkbox&#x27;);
  }).then(function() {
    return protractor.promise.fulfilled();
  });
};

/**
 * Tests if a header exists.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.isTableHeader(&#x27;Action&#x27;).then(function(isHeader) {
 *       console.log(&#x27;Is there a column title named &quot;Action&quot; ? &#x27; + isHeader);
 *     });
 *
 * @method isTableHeader
 * @param {String} name The title of the header to look for
 * @return {Promise} Promise resolving with a boolean indicating if the table header exists or not
 */
TablePage.prototype.isTableHeader = function(name) {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();

    self.headerElements.filter(function(thElement, index) {
      return thElement.getText().then(function(text) {
        return text === name;
      });
    }).then(function(thElements) {
      deferred.fulfill(thElements.length ? true : false);
    });

    return deferred.promise;
  });
};

/**
 * Gets the index of a header in the list of headers.
 *
 * Be careful, the header index starts at 1 (not 0) due to the checkboxes occupying first column on each line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getTableHeaderIndex(&#x27;Action&#x27;).then(function(index) {
 *       console.log(&#x27;Action header index is &#x27; + index);
 *     });
 *
 * @method getTableHeaderIndex
 * @param {String} name The title of the header to look for
 * @return {Promise} Promise resolving with the index of the header
 */
TablePage.prototype.getTableHeaderIndex = function(name) {
  var self = this;

  return browser.waitForAngular().then(function() {
    var deferred = protractor.promise.defer();
    var headerIndex;

    self.headerElements.filter(function(thElement, index) {
      return thElement.getText().then(function(text) {
        if (text === name) {
          headerIndex = index;
          return true;
        }

        return false;
      });
    }).then(function(thElements) {
      if (thElements.length)
        deferred.fulfill(headerIndex + 1);
      else
        deferred.reject(new Error(&#x27;Header &#x27; + name + &#x27; not found&#x27;));
    });

    return deferred.promise;
  });
};

/**
 * Removes a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.removeLine(&#x27;My line&#x27;).then(function() {
 *       console.log(&#x27;Line removed&#x27;);
 *     });
 *
 * @method removeLine
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving when the line has been removed
 */
TablePage.prototype.removeLine = function(lineFinder) {
  var self = this;

  return browser.waitForAngular().then(function() {
    return self.performAction(lineFinder, self.translations.CORE.UI.REMOVE, true);
  });
};

/**
 * Removes all lines in the page.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.removeAllLinesInPage().then(function() {
 *       console.log(&#x27;All lines in the page have been removed&#x27;);
 *     });
 *
 * @method removeAllLinesInPage
 * @return {Promise} Promise resolving when lines have been removed
 */
TablePage.prototype.removeAllLinesInPage = function() {
  var self = this;

  return this.selectAllLines().then(function() {
    return self.removeAllSelectedLinesInPage();
  });
};

/**
 * Removes all selected lines in the page.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.removeAllLinesInPage().then(function() {
 *       console.log(&#x27;Selected lines in the page have been removed&#x27;);
 *     });
 *
 * @method removeAllSelectedLinesInPage
 * @return {Promise} Promise resolving when lines have been removed
 */
TablePage.prototype.removeAllSelectedLinesInPage = function() {
  var self = this;

  return browser.waitForAngular().then(function() {
    return self.performMultipleAction(self.translations.CORE.UI.REMOVE, true);
  });
};

/**
 * Tests if the edition form is in error.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.isEditionFormOnError().then(function(isOnError) {
 *       console.log(&#x27;Is edition form on error ? &#x27; + isOnError);
 *     });
 *
 * @method isEditionFormOnError
 * @return {Promise} Promise resolving with a boolean indicating if the edition form is on error
 */
TablePage.prototype.isEditionFormOnError = function() {
  return this.getEditionFormErrors().then(function(errors) {
    return protractor.promise.fulfilled(errors.length ? true : false);
  });
};

/**
 * Gets the list of edition form error messages.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getEditionFormErrors().then(function(errors) {
 *       console.log(errors);
 *     });
 *
 * @method getEditionFormErrors
 * @return {Promise} Promise resolving with the list of errors
 */
TablePage.prototype.getEditionFormErrors = function() {
  var self = this;

  return browser.waitForAngular().then(function() {
    var fields = self.getEditFormFields(self.lineDetailElement.element(by.css(&#x27;.detail&#x27;)));
    var promises = [];

    for (var fieldName in fields) {
      var field = fields[fieldName];
      promises.push(field.getErrorMessage());
    }

    return protractor.promise.all(promises).then(function(errors) {
      errors = errors.filter(function(text) {
        return text;
      });
      return protractor.promise.fulfilled(errors);
    });
  });

};

/**
 * Gets a field text for a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *
 *     // Get text value of the &quot;title&quot; field for the line &quot;Line name&quot;
 *     // &quot;title&quot; field must be defined by getEditFormFields() method
 *     page.getLineFieldText(&#x27;Line name&#x27;, &#x27;title&#x27;).then(function(text) {
 *       console.log(text);
 *     });
 *
 * @method getLineFieldText
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @param {String} field The field id as described by getEditFormFields() method
 * @return {Promise} Promise resolving with the field text
 */
TablePage.prototype.getLineFieldText = function(lineFinder, field) {
  var self = this;

  // Close eventually opened line
  return this.closeLine().then(function() {
    var fields = self.getEditFormFields(self.lineDetailElement);

    // Open line
    self.openLine(lineFinder);

    return fields[field].getText();
  }).then(function(text) {
    return protractor.promise.fulfilled(text);
  });
};

/**
 * Gets column value for a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *
 *     // Get value of the third column for the line &quot;Line name&quot;
 *     page.getLineCellValue(&#x27;Line name&#x27;, 3).then(function(text) {
 *       console.log(text);
 *     });
 *
 * @method getLineCellValue
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @param {Number} index Index of the column to read
 * @return {Promise} Promise resolving with the cell value
 */
TablePage.prototype.getLineCellValue = function(lineFinder, index) {
  return this.getLine(lineFinder).then(function(line) {
    return line.all(by.css(&#x27;td&#x27;)).get(index + 1).getText();
  });
};

/**
 * Gets all column values for a line.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.getLineCellValues(&#x27;Line name&#x27;).then(function(cellValues) {
 *       console.log(cellValues);
 *     });
 *
 * @method getLineCellValues
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @return {Promise} Promise resolving with all cell values
 */
TablePage.prototype.getLineCellValues = function(lineFinder) {
  var deferred = protractor.promise.defer();
  var values = [];

  this.getLine(lineFinder).then(function(line) {
    line.all(by.css(&#x27;td&#x27;)).each(function(tdElement, index) {
      tdElement.getText().then(function(value) {
        values.push(value);
      });
    }).then(function() {
      deferred.fulfill(values);
    }, function(error) {
      deferred.reject(error);
    });
  });


  return deferred.promise;
};

/**
 * Tests if line cells contain a text.
 *
 * @example
 *
 *     // With MyTablePage extending TablePage
 *     var page = new MyTablePage();
 *     page.logAsAdmin();
 *     page.load();
 *     page.lineCellContain(&#x27;Line name&#x27;, &#x27;Text&#x27;).then(function(contain) {
 *       console.log(&#x27;Does my line &quot;Line name&quot; have a cell containing &quot;Text&quot; ? &#x27; + contain);
 *     });
 *
 * @method lineCellContain
 * @param {String|ElementFinder} lineFinder The name of the line (each column will be compared to this value) or
 * the line element
 * @param {String} value Value to look for
 * @return {Promise} Promise resolving with a boolean indicating if the given value correspond to a cell
 */
TablePage.prototype.lineCellContain = function(lineFinder, value) {
  var deferred = protractor.promise.defer();

  this.getLine(lineFinder).then(function(line) {
    line.all(by.css(&#x27;td&#x27;)).filter(function(tdElement, index) {
      return tdElement.getText().then(function(text) {
        return text === value;
      });
    }).then(function(tdElements) {
      deferred.fulfill(tdElements.length ? true : false);
    }, function(error) {
      deferred.reject(error);
    });
  });

  return deferred.promise;
};

/**
 * Adds a new line.
 *
 * User must be logged and have permission to create line on this page.
 *
 * @method addLine
 * @param {String} name Line name
 * @param {Object} [data] Additional data depending on page type
 * @return {Promise} Promise resolving when the line has been added
 */
TablePage.prototype.addLine = function(name, data) {
  throw new Error(&#x27;addLine method is not implemented for this page&#x27;);
};

/**
 * Gets search engine fields.
 *
 * @param {ElementFinder} Search engine form element
 * @return {Object} The list of fields
 */
TablePage.prototype.getSearchFields = function(form) {
  throw new Error(&#x27;Method getSearchFields not implemented for this page&#x27;);
};

/**
 * Gets add form fields.
 *
 * @method getAddFormFields
 * @param {ElementFinder} Add form element
 * @return {Object} The list of fields
 */
TablePage.prototype.getAddFormFields = function(form) {
  throw new Error(&#x27;Method getAddFormFields not implemented for this page&#x27;);
};

/**
 * Gets edit form fields.
 *
 * @method getEditFormFields
 * @param {ElementFinder} Edit form element
 * @return {Obect} The list of fields
 */
TablePage.prototype.getEditFormFields = function(form) {
  throw new Error(&#x27;Method getEditFormFields not implemented for this page&#x27;);
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
